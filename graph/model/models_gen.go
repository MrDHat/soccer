// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphmodel

import (
	"fmt"
	"io"
	"strconv"
)

type Category struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}

type NewCategory struct {
	Name string `json:"name"`
}

type NewTodo struct {
	Text   string `json:"text"`
	UserID string `json:"userId"`
}

type PaginationInput struct {
	Page  int64 `json:"page"`
	Limit int64 `json:"limit"`
}

type Team struct {
	ID   *int64  `json:"id"`
	Name *string `json:"name"`
}

type Todo struct {
	ID   int64  `json:"id"`
	Text string `json:"text"`
	Done bool   `json:"done"`
}

type User struct {
	ID          int64   `json:"id"`
	FirstName   *string `json:"firstName"`
	LastName    *string `json:"lastName"`
	FullName    *string `json:"fullName"`
	Homezip     *string `json:"homezip"`
	Alias       *string `json:"alias"`
	Headline    *string `json:"headline"`
	ImageURL    *string `json:"imageUrl"`
	PhoneNumber *string `json:"phoneNumber"`
	Gender      *Gender `json:"gender"`
	About       *string `json:"about"`
	CreatedAt   int64   `json:"createdAt"`
	UpdatedAt   int64   `json:"updatedAt"`
}

type UserProfile struct {
	ID        int64   `json:"id"`
	Username  *string `json:"username"`
	Bio       *string `json:"bio"`
	Gender    *string `json:"gender"`
	ImageURL  *string `json:"imageUrl"`
	ImageType *string `json:"imageType"`
	JoinedAt  *int64  `json:"joinedAt"`
}

type Gender string

const (
	GenderMale   Gender = "Male"
	GenderFemale Gender = "Female"
	GenderOther  Gender = "Other"
)

var AllGender = []Gender{
	GenderMale,
	GenderFemale,
	GenderOther,
}

func (e Gender) IsValid() bool {
	switch e {
	case GenderMale, GenderFemale, GenderOther:
		return true
	}
	return false
}

func (e Gender) String() string {
	return string(e)
}

func (e *Gender) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Gender(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Gender", str)
	}
	return nil
}

func (e Gender) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortBy string

const (
	SortByLatest SortBy = "latest"
	SortByOldest SortBy = "oldest"
)

var AllSortBy = []SortBy{
	SortByLatest,
	SortByOldest,
}

func (e SortBy) IsValid() bool {
	switch e {
	case SortByLatest, SortByOldest:
		return true
	}
	return false
}

func (e SortBy) String() string {
	return string(e)
}

func (e *SortBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortBy", str)
	}
	return nil
}

func (e SortBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
